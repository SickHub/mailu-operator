// Package mailu provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.3.0 DO NOT EDIT.
package mailu

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	BearerScopes = "Bearer.Scopes"
)

// Alias defines model for Alias.
type Alias struct {
	// Comment a comment
	Comment     *string   `json:"comment,omitempty"`
	Destination *[]string `json:"destination,omitempty"`

	// Email the alias email address
	Email string `json:"email"`

	// Wildcard enable SQL Like wildcard syntax
	Wildcard *bool `json:"wildcard,omitempty"`
}

// AliasUpdate defines model for AliasUpdate.
type AliasUpdate struct {
	// Comment a comment
	Comment     *string   `json:"comment,omitempty"`
	Destination *[]string `json:"destination,omitempty"`

	// Wildcard enable SQL Like wildcard syntax
	Wildcard *bool `json:"wildcard,omitempty"`
}

// AlternativeDomain defines model for AlternativeDomain.
type AlternativeDomain struct {
	// Domain domain FQDN
	Domain string `json:"domain"`

	// Name alternative FQDN
	Name string `json:"name"`
}

// Domain defines model for Domain.
type Domain struct {
	Alternatives *[]string `json:"alternatives,omitempty"`

	// Comment a comment
	Comment *string `json:"comment,omitempty"`

	// MaxAliases maximum number of aliases
	MaxAliases *int `json:"max_aliases,omitempty"`

	// MaxQuotaBytes maximum quota for mailbox
	MaxQuotaBytes *int `json:"max_quota_bytes,omitempty"`

	// MaxUsers maximum number of users
	MaxUsers *int `json:"max_users,omitempty"`

	// Name FQDN (e.g. example.com)
	Name string `json:"name"`

	// SignupEnabled allow signup
	SignupEnabled *bool `json:"signup_enabled,omitempty"`
}

// DomainGet defines model for DomainGet.
type DomainGet struct {
	Alternatives *[]string `json:"alternatives,omitempty"`

	// Comment a comment
	Comment        *string   `json:"comment,omitempty"`
	DnsAutoconfig  *[]string `json:"dns_autoconfig,omitempty"`
	DnsDkim        *string   `json:"dns_dkim,omitempty"`
	DnsDmarc       *string   `json:"dns_dmarc,omitempty"`
	DnsDmarcReport *string   `json:"dns_dmarc_report,omitempty"`
	DnsMx          *string   `json:"dns_mx,omitempty"`
	DnsSpf         *string   `json:"dns_spf,omitempty"`
	DnsTlsa        *[]string `json:"dns_tlsa,omitempty"`
	Managers       *[]string `json:"managers,omitempty"`

	// MaxAliases maximum number of aliases
	MaxAliases *int `json:"max_aliases,omitempty"`

	// MaxQuotaBytes maximum quota for mailbox
	MaxQuotaBytes *int `json:"max_quota_bytes,omitempty"`

	// MaxUsers maximum number of users
	MaxUsers *int `json:"max_users,omitempty"`

	// Name FQDN (e.g. example.com)
	Name string `json:"name"`

	// SignupEnabled allow signup
	SignupEnabled *bool `json:"signup_enabled,omitempty"`
}

// DomainUpdate defines model for DomainUpdate.
type DomainUpdate struct {
	Alternatives *[]string `json:"alternatives,omitempty"`

	// Comment a comment
	Comment *string `json:"comment,omitempty"`

	// MaxAliases maximum number of aliases
	MaxAliases *int `json:"max_aliases,omitempty"`

	// MaxQuotaBytes maximum quota for mailbox
	MaxQuotaBytes *int `json:"max_quota_bytes,omitempty"`

	// MaxUsers maximum number of users
	MaxUsers *int `json:"max_users,omitempty"`

	// SignupEnabled allow signup
	SignupEnabled *bool `json:"signup_enabled,omitempty"`
}

// Manager defines model for Manager.
type Manager struct {
	Managers *[]string `json:"managers,omitempty"`
}

// ManagerCreate defines model for ManagerCreate.
type ManagerCreate struct {
	// UserEmail email address of manager
	UserEmail string `json:"user_email"`
}

// Relay defines model for Relay.
type Relay struct {
	// Comment a comment
	Comment *string `json:"comment,omitempty"`

	// Name relayed domain name
	Name string `json:"name"`

	// Smtp remote host
	Smtp *string `json:"smtp,omitempty"`
}

// RelayUpdate defines model for RelayUpdate.
type RelayUpdate struct {
	// Comment a comment
	Comment *string `json:"comment,omitempty"`

	// Smtp remote host
	Smtp *string `json:"smtp,omitempty"`
}

// Response defines model for Response.
type Response struct {
	Code    *int    `json:"code,omitempty"`
	Message *string `json:"message,omitempty"`
}

// TokenGetResponse defines model for TokenGetResponse.
type TokenGetResponse struct {
	AuthorizedIP *[]string `json:"AuthorizedIP,omitempty"`

	// Created The date when the token was created
	Created *string `json:"Created,omitempty"`

	// LastEdit The date when the token was last modifified
	LastEdit *string `json:"Last edit,omitempty"`

	// Comment A description for the token. This description is shown on the Authentication tokens page
	Comment *string `json:"comment,omitempty"`

	// Email The email address of the user
	Email *string `json:"email,omitempty"`

	// Id The record id of the token (unique identifier)
	Id *string `json:"id,omitempty"`
}

// TokenPost defines model for TokenPost.
type TokenPost struct {
	AuthorizedIP *[]string `json:"AuthorizedIP,omitempty"`

	// Comment A description for the token. This description is shown on the Authentication tokens page
	Comment *string `json:"comment,omitempty"`

	// Email The email address of the user
	Email string `json:"email"`
}

// TokenPost2 defines model for TokenPost2.
type TokenPost2 struct {
	AuthorizedIP *[]string `json:"AuthorizedIP,omitempty"`

	// Comment A description for the token. This description is shown on the Authentication tokens page
	Comment *string `json:"comment,omitempty"`
}

// TokenPostResponse defines model for TokenPostResponse.
type TokenPostResponse struct {
	AuthorizedIP *[]string `json:"AuthorizedIP,omitempty"`

	// Created The date when the token was created
	Created *string `json:"Created,omitempty"`

	// Comment A description for the token. This description is shown on the Authentication tokens page
	Comment *string `json:"comment,omitempty"`

	// Email The email address of the user
	Email *string `json:"email,omitempty"`

	// Id The record id of the token (unique identifier)
	Id *string `json:"id,omitempty"`

	// Token The created authentication token for the user.
	Token *string `json:"token,omitempty"`
}

// UserCreate defines model for UserCreate.
type UserCreate struct {
	// AllowSpoofing Allow the user to spoof the sender (send email as anyone)
	AllowSpoofing *bool `json:"allow_spoofing,omitempty"`

	// ChangePwNextLogin Force the user to change their password at next login
	ChangePwNextLogin *bool `json:"change_pw_next_login,omitempty"`

	// Comment A description for the user. This description is shown on the Users page
	Comment *string `json:"comment,omitempty"`

	// DisplayedName The display name of the user within the Admin GUI
	DisplayedName *string `json:"displayed_name,omitempty"`

	// Email The email address of the user
	Email string `json:"email"`

	// EnableImap Allow email retrieval via IMAP
	EnableImap *bool `json:"enable_imap,omitempty"`

	// EnablePop Allow email retrieval via POP3
	EnablePop *bool `json:"enable_pop,omitempty"`

	// Enabled Enable the user. When an user is disabled, the user is unable to login to the Admin GUI or webmail or access his email via IMAP/POP3 or send mail
	Enabled            *bool     `json:"enabled,omitempty"`
	ForwardDestination *[]string `json:"forward_destination,omitempty"`

	// ForwardEnabled Enable auto forwarding
	ForwardEnabled *bool `json:"forward_enabled,omitempty"`

	// ForwardKeep Keep a copy of the forwarded email in the inbox
	ForwardKeep *bool `json:"forward_keep,omitempty"`

	// GlobalAdmin Make the user a global administrator
	GlobalAdmin *bool `json:"global_admin,omitempty"`

	// QuotaBytes The maximum quota for the userâ€™s email box in bytes
	QuotaBytes *int `json:"quota_bytes,omitempty"`

	// RawPassword The raw (plain text) password of the user. Mailu will hash the password using BCRYPT-SHA256
	RawPassword string `json:"raw_password"`

	// ReplyBody The body of the automatic reply email
	ReplyBody *string `json:"reply_body,omitempty"`

	// ReplyEnabled Enable automatic replies. This is also known as out of office (ooo) or out of facility (oof) replies
	ReplyEnabled *bool `json:"reply_enabled,omitempty"`

	// ReplyEnddate End date for automatic replies in YYYY-MM-DD format.
	ReplyEnddate *openapi_types.Date `json:"reply_enddate,omitempty"`

	// ReplyStartdate Start date for automatic replies in YYYY-MM-DD format.
	ReplyStartdate *openapi_types.Date `json:"reply_startdate,omitempty"`

	// ReplySubject Optional subject for the automatic reply
	ReplySubject *string `json:"reply_subject,omitempty"`

	// SpamEnabled Enable the spam filter
	SpamEnabled *bool `json:"spam_enabled,omitempty"`

	// SpamMarkAsRead Enable marking spam mails as read
	SpamMarkAsRead *bool `json:"spam_mark_as_read,omitempty"`

	// SpamThreshold The user defined spam filter tolerance
	SpamThreshold *int `json:"spam_threshold,omitempty"`
}

// UserGet defines model for UserGet.
type UserGet struct {
	// AllowSpoofing Allow the user to spoof the sender (send email as anyone)
	AllowSpoofing *bool `json:"allow_spoofing,omitempty"`

	// ChangePwNextLogin Force the user to change their password at next login
	ChangePwNextLogin *bool `json:"change_pw_next_login,omitempty"`

	// Comment A description for the user. This description is shown on the Users page
	Comment *string `json:"comment,omitempty"`

	// DisplayedName The display name of the user within the Admin GUI
	DisplayedName *string `json:"displayed_name,omitempty"`

	// Email The email address of the user
	Email *string `json:"email,omitempty"`

	// EnableImap Allow email retrieval via IMAP
	EnableImap *bool `json:"enable_imap,omitempty"`

	// EnablePop Allow email retrieval via POP3
	EnablePop *bool `json:"enable_pop,omitempty"`

	// Enabled Enable the user. When an user is disabled, the user is unable to login to the Admin GUI or webmail or access his email via IMAP/POP3 or send mail
	Enabled            *bool     `json:"enabled,omitempty"`
	ForwardDestination *[]string `json:"forward_destination,omitempty"`

	// ForwardEnabled Enable auto forwarding
	ForwardEnabled *bool `json:"forward_enabled,omitempty"`

	// ForwardKeep Keep a copy of the forwarded email in the inbox
	ForwardKeep *bool `json:"forward_keep,omitempty"`

	// GlobalAdmin Make the user a global administrator
	GlobalAdmin *bool `json:"global_admin,omitempty"`

	// Password Hash of the user's password; Example='$bcrypt-sha256$v=2,t=2b,r=12$fmsAdJbYAD1gGQIE5nfJq.$zLkQUEs2XZfTpAEpcix/1k5UTNPm0jO'
	Password *string `json:"password,omitempty"`

	// QuotaBytes The maximum quota for the userâ€™s email box in bytes
	QuotaBytes *int `json:"quota_bytes,omitempty"`

	// QuotaBytesUsed The size of the userâ€™s email box in bytes
	QuotaBytesUsed *int `json:"quota_bytes_used,omitempty"`

	// ReplyBody The body of the automatic reply email
	ReplyBody *string `json:"reply_body,omitempty"`

	// ReplyEnabled Enable automatic replies. This is also known as out of office (ooo) or out of facility (oof) replies
	ReplyEnabled *bool `json:"reply_enabled,omitempty"`

	// ReplyEnddate End date for automatic replies in YYYY-MM-DD format.
	ReplyEnddate *openapi_types.Date `json:"reply_enddate,omitempty"`

	// ReplyStartdate Start date for automatic replies in YYYY-MM-DD format.
	ReplyStartdate *openapi_types.Date `json:"reply_startdate,omitempty"`

	// ReplySubject Optional subject for the automatic reply
	ReplySubject *string `json:"reply_subject,omitempty"`

	// SpamEnabled Enable the spam filter
	SpamEnabled *bool `json:"spam_enabled,omitempty"`

	// SpamMarkAsRead Enable marking spam mails as read
	SpamMarkAsRead *bool `json:"spam_mark_as_read,omitempty"`

	// SpamThreshold The user defined spam filter tolerance
	SpamThreshold *int `json:"spam_threshold,omitempty"`
}

// UserUpdate defines model for UserUpdate.
type UserUpdate struct {
	// AllowSpoofing Allow the user to spoof the sender (send email as anyone)
	AllowSpoofing *bool `json:"allow_spoofing,omitempty"`

	// ChangePwNextLogin Force the user to change their password at next login
	ChangePwNextLogin *bool `json:"change_pw_next_login,omitempty"`

	// Comment A description for the user. This description is shown on the Users page
	Comment *string `json:"comment,omitempty"`

	// DisplayedName The display name of the user within the Admin GUI
	DisplayedName *string `json:"displayed_name,omitempty"`

	// EnableImap Allow email retrieval via IMAP
	EnableImap *bool `json:"enable_imap,omitempty"`

	// EnablePop Allow email retrieval via POP3
	EnablePop *bool `json:"enable_pop,omitempty"`

	// Enabled Enable the user. When an user is disabled, the user is unable to login to the Admin GUI or webmail or access his email via IMAP/POP3 or send mail
	Enabled            *bool     `json:"enabled,omitempty"`
	ForwardDestination *[]string `json:"forward_destination,omitempty"`

	// ForwardEnabled Enable auto forwarding
	ForwardEnabled *bool `json:"forward_enabled,omitempty"`

	// ForwardKeep Keep a copy of the forwarded email in the inbox
	ForwardKeep *bool `json:"forward_keep,omitempty"`

	// GlobalAdmin Make the user a global administrator
	GlobalAdmin *bool `json:"global_admin,omitempty"`

	// QuotaBytes The maximum quota for the userâ€™s email box in bytes
	QuotaBytes *int `json:"quota_bytes,omitempty"`

	// RawPassword The raw (plain text) password of the user. Mailu will hash the password using BCRYPT-SHA256
	RawPassword *string `json:"raw_password,omitempty"`

	// ReplyBody The body of the automatic reply email
	ReplyBody *string `json:"reply_body,omitempty"`

	// ReplyEnabled Enable automatic replies. This is also known as out of office (ooo) or out of facility (oof) replies
	ReplyEnabled *bool `json:"reply_enabled,omitempty"`

	// ReplyEnddate End date for automatic replies in YYYY-MM-DD format.
	ReplyEnddate *openapi_types.Date `json:"reply_enddate,omitempty"`

	// ReplyStartdate Start date for automatic replies in YYYY-MM-DD format.
	ReplyStartdate *openapi_types.Date `json:"reply_startdate,omitempty"`

	// ReplySubject Optional subject for the automatic reply
	ReplySubject *string `json:"reply_subject,omitempty"`

	// SpamEnabled Enable the spam filter
	SpamEnabled *bool `json:"spam_enabled,omitempty"`

	// SpamMarkAsRead Enable marking spam mails as read
	SpamMarkAsRead *bool `json:"spam_mark_as_read,omitempty"`

	// SpamThreshold The user defined spam filter tolerance
	SpamThreshold *int `json:"spam_threshold,omitempty"`
}

// CreateAliasJSONRequestBody defines body for CreateAlias for application/json ContentType.
type CreateAliasJSONRequestBody = Alias

// UpdateAliasJSONRequestBody defines body for UpdateAlias for application/json ContentType.
type UpdateAliasJSONRequestBody = AliasUpdate

// CreateAlternativeJSONRequestBody defines body for CreateAlternative for application/json ContentType.
type CreateAlternativeJSONRequestBody = AlternativeDomain

// CreateDomainJSONRequestBody defines body for CreateDomain for application/json ContentType.
type CreateDomainJSONRequestBody = Domain

// UpdateDomainJSONRequestBody defines body for UpdateDomain for application/json ContentType.
type UpdateDomainJSONRequestBody = DomainUpdate

// CreateManagerJSONRequestBody defines body for CreateManager for application/json ContentType.
type CreateManagerJSONRequestBody = ManagerCreate

// CreateRelayJSONRequestBody defines body for CreateRelay for application/json ContentType.
type CreateRelayJSONRequestBody = Relay

// UpdateRelayJSONRequestBody defines body for UpdateRelay for application/json ContentType.
type UpdateRelayJSONRequestBody = RelayUpdate

// CreateTokenJSONRequestBody defines body for CreateToken for application/json ContentType.
type CreateTokenJSONRequestBody = TokenPost

// UpdateTokenJSONRequestBody defines body for UpdateToken for application/json ContentType.
type UpdateTokenJSONRequestBody = TokenPost2

// CreateUserJSONRequestBody defines body for CreateUser for application/json ContentType.
type CreateUserJSONRequestBody = UserCreate

// UpdateUserJSONRequestBody defines body for UpdateUser for application/json ContentType.
type UpdateUserJSONRequestBody = UserUpdate

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// ListAlias request
	ListAlias(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAliasWithBody request with any body
	CreateAliasWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateAlias(ctx context.Context, body CreateAliasJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindAliasFilterDomain request
	FindAliasFilterDomain(ctx context.Context, domain string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAlias request
	DeleteAlias(ctx context.Context, alias string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindAlias request
	FindAlias(ctx context.Context, alias string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateAliasWithBody request with any body
	UpdateAliasWithBody(ctx context.Context, alias string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateAlias(ctx context.Context, alias string, body UpdateAliasJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAlternative request
	ListAlternative(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAlternativeWithBody request with any body
	CreateAlternativeWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateAlternative(ctx context.Context, body CreateAlternativeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAlternative request
	DeleteAlternative(ctx context.Context, alt string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindAlternative request
	FindAlternative(ctx context.Context, alt string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListDomain request
	ListDomain(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateDomainWithBody request with any body
	CreateDomainWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateDomain(ctx context.Context, body CreateDomainJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteDomain request
	DeleteDomain(ctx context.Context, domain string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindDomain request
	FindDomain(ctx context.Context, domain string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateDomainWithBody request with any body
	UpdateDomainWithBody(ctx context.Context, domain string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateDomain(ctx context.Context, domain string, body UpdateDomainJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GenerateDkim request
	GenerateDkim(ctx context.Context, domain string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListManagers request
	ListManagers(ctx context.Context, domain string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateManagerWithBody request with any body
	CreateManagerWithBody(ctx context.Context, domain string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateManager(ctx context.Context, domain string, body CreateManagerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteManager request
	DeleteManager(ctx context.Context, domain string, email string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindManager request
	FindManager(ctx context.Context, domain string, email string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListUserDomain request
	ListUserDomain(ctx context.Context, domain string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListRelays request
	ListRelays(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateRelayWithBody request with any body
	CreateRelayWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateRelay(ctx context.Context, body CreateRelayJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteRelay request
	DeleteRelay(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindRelay request
	FindRelay(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateRelayWithBody request with any body
	UpdateRelayWithBody(ctx context.Context, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateRelay(ctx context.Context, name string, body UpdateRelayJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListTokens request
	ListTokens(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteToken request
	DeleteToken(ctx context.Context, tokenId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindToken request
	FindToken(ctx context.Context, tokenId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateTokenWithBody request with any body
	UpdateTokenWithBody(ctx context.Context, tokenId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateToken(ctx context.Context, tokenId string, body UpdateTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindTokensOfUser request
	FindTokensOfUser(ctx context.Context, email string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateTokenWithBody request with any body
	CreateTokenWithBody(ctx context.Context, email string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateToken(ctx context.Context, email string, body CreateTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListUser request
	ListUser(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateUserWithBody request with any body
	CreateUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateUser(ctx context.Context, body CreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteUser request
	DeleteUser(ctx context.Context, email string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FindUser request
	FindUser(ctx context.Context, email string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateUserWithBody request with any body
	UpdateUserWithBody(ctx context.Context, email string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateUser(ctx context.Context, email string, body UpdateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) ListAlias(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAliasRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAliasWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAliasRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAlias(ctx context.Context, body CreateAliasJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAliasRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindAliasFilterDomain(ctx context.Context, domain string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindAliasFilterDomainRequest(c.Server, domain)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAlias(ctx context.Context, alias string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAliasRequest(c.Server, alias)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindAlias(ctx context.Context, alias string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindAliasRequest(c.Server, alias)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAliasWithBody(ctx context.Context, alias string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAliasRequestWithBody(c.Server, alias, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAlias(ctx context.Context, alias string, body UpdateAliasJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAliasRequest(c.Server, alias, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAlternative(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAlternativeRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAlternativeWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAlternativeRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAlternative(ctx context.Context, body CreateAlternativeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAlternativeRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAlternative(ctx context.Context, alt string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAlternativeRequest(c.Server, alt)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindAlternative(ctx context.Context, alt string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindAlternativeRequest(c.Server, alt)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListDomain(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListDomainRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDomainWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDomainRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDomain(ctx context.Context, body CreateDomainJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDomainRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteDomain(ctx context.Context, domain string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteDomainRequest(c.Server, domain)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindDomain(ctx context.Context, domain string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindDomainRequest(c.Server, domain)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateDomainWithBody(ctx context.Context, domain string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateDomainRequestWithBody(c.Server, domain, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateDomain(ctx context.Context, domain string, body UpdateDomainJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateDomainRequest(c.Server, domain, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GenerateDkim(ctx context.Context, domain string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGenerateDkimRequest(c.Server, domain)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListManagers(ctx context.Context, domain string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListManagersRequest(c.Server, domain)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateManagerWithBody(ctx context.Context, domain string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateManagerRequestWithBody(c.Server, domain, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateManager(ctx context.Context, domain string, body CreateManagerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateManagerRequest(c.Server, domain, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteManager(ctx context.Context, domain string, email string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteManagerRequest(c.Server, domain, email)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindManager(ctx context.Context, domain string, email string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindManagerRequest(c.Server, domain, email)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListUserDomain(ctx context.Context, domain string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListUserDomainRequest(c.Server, domain)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListRelays(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListRelaysRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRelayWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRelayRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRelay(ctx context.Context, body CreateRelayJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRelayRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRelay(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRelayRequest(c.Server, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindRelay(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindRelayRequest(c.Server, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRelayWithBody(ctx context.Context, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRelayRequestWithBody(c.Server, name, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRelay(ctx context.Context, name string, body UpdateRelayJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRelayRequest(c.Server, name, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListTokens(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListTokensRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTokenRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateToken(ctx context.Context, body CreateTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTokenRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteToken(ctx context.Context, tokenId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTokenRequest(c.Server, tokenId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindToken(ctx context.Context, tokenId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindTokenRequest(c.Server, tokenId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateTokenWithBody(ctx context.Context, tokenId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateTokenRequestWithBody(c.Server, tokenId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateToken(ctx context.Context, tokenId string, body UpdateTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateTokenRequest(c.Server, tokenId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindTokensOfUser(ctx context.Context, email string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindTokensOfUserRequest(c.Server, email)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListUser(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListUserRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUserRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUser(ctx context.Context, body CreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUserRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteUser(ctx context.Context, email string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteUserRequest(c.Server, email)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FindUser(ctx context.Context, email string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFindUserRequest(c.Server, email)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUserWithBody(ctx context.Context, email string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserRequestWithBody(c.Server, email, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUser(ctx context.Context, email string, body UpdateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserRequest(c.Server, email, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewListAliasRequest generates requests for ListAlias
func NewListAliasRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/alias")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateAliasRequest calls the generic CreateAlias builder with application/json body
func NewCreateAliasRequest(server string, body CreateAliasJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateAliasRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateAliasRequestWithBody generates requests for CreateAlias with any type of body
func NewCreateAliasRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/alias")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFindAliasFilterDomainRequest generates requests for FindAliasFilterDomain
func NewFindAliasFilterDomainRequest(server string, domain string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "domain", runtime.ParamLocationPath, domain)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/alias/destination/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteAliasRequest generates requests for DeleteAlias
func NewDeleteAliasRequest(server string, alias string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "alias", runtime.ParamLocationPath, alias)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/alias/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindAliasRequest generates requests for FindAlias
func NewFindAliasRequest(server string, alias string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "alias", runtime.ParamLocationPath, alias)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/alias/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateAliasRequest calls the generic UpdateAlias builder with application/json body
func NewUpdateAliasRequest(server string, alias string, body UpdateAliasJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateAliasRequestWithBody(server, alias, "application/json", bodyReader)
}

// NewUpdateAliasRequestWithBody generates requests for UpdateAlias with any type of body
func NewUpdateAliasRequestWithBody(server string, alias string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "alias", runtime.ParamLocationPath, alias)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/alias/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAlternativeRequest generates requests for ListAlternative
func NewListAlternativeRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/alternative")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateAlternativeRequest calls the generic CreateAlternative builder with application/json body
func NewCreateAlternativeRequest(server string, body CreateAlternativeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateAlternativeRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateAlternativeRequestWithBody generates requests for CreateAlternative with any type of body
func NewCreateAlternativeRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/alternative")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteAlternativeRequest generates requests for DeleteAlternative
func NewDeleteAlternativeRequest(server string, alt string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "alt", runtime.ParamLocationPath, alt)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/alternative/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindAlternativeRequest generates requests for FindAlternative
func NewFindAlternativeRequest(server string, alt string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "alt", runtime.ParamLocationPath, alt)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/alternative/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListDomainRequest generates requests for ListDomain
func NewListDomainRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/domain")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateDomainRequest calls the generic CreateDomain builder with application/json body
func NewCreateDomainRequest(server string, body CreateDomainJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateDomainRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateDomainRequestWithBody generates requests for CreateDomain with any type of body
func NewCreateDomainRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/domain")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteDomainRequest generates requests for DeleteDomain
func NewDeleteDomainRequest(server string, domain string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "domain", runtime.ParamLocationPath, domain)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/domain/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindDomainRequest generates requests for FindDomain
func NewFindDomainRequest(server string, domain string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "domain", runtime.ParamLocationPath, domain)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/domain/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateDomainRequest calls the generic UpdateDomain builder with application/json body
func NewUpdateDomainRequest(server string, domain string, body UpdateDomainJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateDomainRequestWithBody(server, domain, "application/json", bodyReader)
}

// NewUpdateDomainRequestWithBody generates requests for UpdateDomain with any type of body
func NewUpdateDomainRequestWithBody(server string, domain string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "domain", runtime.ParamLocationPath, domain)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/domain/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGenerateDkimRequest generates requests for GenerateDkim
func NewGenerateDkimRequest(server string, domain string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "domain", runtime.ParamLocationPath, domain)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/domain/%s/dkim", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListManagersRequest generates requests for ListManagers
func NewListManagersRequest(server string, domain string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "domain", runtime.ParamLocationPath, domain)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/domain/%s/manager", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateManagerRequest calls the generic CreateManager builder with application/json body
func NewCreateManagerRequest(server string, domain string, body CreateManagerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateManagerRequestWithBody(server, domain, "application/json", bodyReader)
}

// NewCreateManagerRequestWithBody generates requests for CreateManager with any type of body
func NewCreateManagerRequestWithBody(server string, domain string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "domain", runtime.ParamLocationPath, domain)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/domain/%s/manager", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteManagerRequest generates requests for DeleteManager
func NewDeleteManagerRequest(server string, domain string, email string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "domain", runtime.ParamLocationPath, domain)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "email", runtime.ParamLocationPath, email)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/domain/%s/manager/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindManagerRequest generates requests for FindManager
func NewFindManagerRequest(server string, domain string, email string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "domain", runtime.ParamLocationPath, domain)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "email", runtime.ParamLocationPath, email)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/domain/%s/manager/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListUserDomainRequest generates requests for ListUserDomain
func NewListUserDomainRequest(server string, domain string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "domain", runtime.ParamLocationPath, domain)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/domain/%s/users", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListRelaysRequest generates requests for ListRelays
func NewListRelaysRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/relay")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateRelayRequest calls the generic CreateRelay builder with application/json body
func NewCreateRelayRequest(server string, body CreateRelayJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateRelayRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateRelayRequestWithBody generates requests for CreateRelay with any type of body
func NewCreateRelayRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/relay")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteRelayRequest generates requests for DeleteRelay
func NewDeleteRelayRequest(server string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/relay/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindRelayRequest generates requests for FindRelay
func NewFindRelayRequest(server string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/relay/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateRelayRequest calls the generic UpdateRelay builder with application/json body
func NewUpdateRelayRequest(server string, name string, body UpdateRelayJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateRelayRequestWithBody(server, name, "application/json", bodyReader)
}

// NewUpdateRelayRequestWithBody generates requests for UpdateRelay with any type of body
func NewUpdateRelayRequestWithBody(server string, name string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/relay/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListTokensRequest generates requests for ListTokens
func NewListTokensRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/token")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateTokenRequest calls the generic CreateToken builder with application/json body
func NewCreateTokenRequest(server string, body CreateTokenJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateTokenRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateTokenRequestWithBody generates requests for CreateToken with any type of body
func NewCreateTokenRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/token")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteTokenRequest generates requests for DeleteToken
func NewDeleteTokenRequest(server string, tokenId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "token_id", runtime.ParamLocationPath, tokenId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/token/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindTokenRequest generates requests for FindToken
func NewFindTokenRequest(server string, tokenId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "token_id", runtime.ParamLocationPath, tokenId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/token/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateTokenRequest calls the generic UpdateToken builder with application/json body
func NewUpdateTokenRequest(server string, tokenId string, body UpdateTokenJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateTokenRequestWithBody(server, tokenId, "application/json", bodyReader)
}

// NewUpdateTokenRequestWithBody generates requests for UpdateToken with any type of body
func NewUpdateTokenRequestWithBody(server string, tokenId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "token_id", runtime.ParamLocationPath, tokenId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/token/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFindTokensOfUserRequest generates requests for FindTokensOfUser
func NewFindTokensOfUserRequest(server string, email string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "email", runtime.ParamLocationPath, email)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tokenuser/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}


// NewListUserRequest generates requests for ListUser
func NewListUserRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateUserRequest calls the generic CreateUser builder with application/json body
func NewCreateUserRequest(server string, body CreateUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateUserRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateUserRequestWithBody generates requests for CreateUser with any type of body
func NewCreateUserRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteUserRequest generates requests for DeleteUser
func NewDeleteUserRequest(server string, email string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "email", runtime.ParamLocationPath, email)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFindUserRequest generates requests for FindUser
func NewFindUserRequest(server string, email string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "email", runtime.ParamLocationPath, email)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateUserRequest calls the generic UpdateUser builder with application/json body
func NewUpdateUserRequest(server string, email string, body UpdateUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateUserRequestWithBody(server, email, "application/json", bodyReader)
}

// NewUpdateUserRequestWithBody generates requests for UpdateUser with any type of body
func NewUpdateUserRequestWithBody(server string, email string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "email", runtime.ParamLocationPath, email)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// ListAliasWithResponse request
	ListAliasWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListAliasResponse, error)

	// CreateAliasWithBodyWithResponse request with any body
	CreateAliasWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAliasResponse, error)

	CreateAliasWithResponse(ctx context.Context, body CreateAliasJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAliasResponse, error)

	// FindAliasFilterDomainWithResponse request
	FindAliasFilterDomainWithResponse(ctx context.Context, domain string, reqEditors ...RequestEditorFn) (*FindAliasFilterDomainResponse, error)

	// DeleteAliasWithResponse request
	DeleteAliasWithResponse(ctx context.Context, alias string, reqEditors ...RequestEditorFn) (*DeleteAliasResponse, error)

	// FindAliasWithResponse request
	FindAliasWithResponse(ctx context.Context, alias string, reqEditors ...RequestEditorFn) (*FindAliasResponse, error)

	// UpdateAliasWithBodyWithResponse request with any body
	UpdateAliasWithBodyWithResponse(ctx context.Context, alias string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAliasResponse, error)

	UpdateAliasWithResponse(ctx context.Context, alias string, body UpdateAliasJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAliasResponse, error)

	// ListAlternativeWithResponse request
	ListAlternativeWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListAlternativeResponse, error)

	// CreateAlternativeWithBodyWithResponse request with any body
	CreateAlternativeWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAlternativeResponse, error)

	CreateAlternativeWithResponse(ctx context.Context, body CreateAlternativeJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAlternativeResponse, error)

	// DeleteAlternativeWithResponse request
	DeleteAlternativeWithResponse(ctx context.Context, alt string, reqEditors ...RequestEditorFn) (*DeleteAlternativeResponse, error)

	// FindAlternativeWithResponse request
	FindAlternativeWithResponse(ctx context.Context, alt string, reqEditors ...RequestEditorFn) (*FindAlternativeResponse, error)

	// ListDomainWithResponse request
	ListDomainWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListDomainResponse, error)

	// CreateDomainWithBodyWithResponse request with any body
	CreateDomainWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDomainResponse, error)

	CreateDomainWithResponse(ctx context.Context, body CreateDomainJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDomainResponse, error)

	// DeleteDomainWithResponse request
	DeleteDomainWithResponse(ctx context.Context, domain string, reqEditors ...RequestEditorFn) (*DeleteDomainResponse, error)

	// FindDomainWithResponse request
	FindDomainWithResponse(ctx context.Context, domain string, reqEditors ...RequestEditorFn) (*FindDomainResponse, error)

	// UpdateDomainWithBodyWithResponse request with any body
	UpdateDomainWithBodyWithResponse(ctx context.Context, domain string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateDomainResponse, error)

	UpdateDomainWithResponse(ctx context.Context, domain string, body UpdateDomainJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateDomainResponse, error)

	// GenerateDkimWithResponse request
	GenerateDkimWithResponse(ctx context.Context, domain string, reqEditors ...RequestEditorFn) (*GenerateDkimResponse, error)

	// ListManagersWithResponse request
	ListManagersWithResponse(ctx context.Context, domain string, reqEditors ...RequestEditorFn) (*ListManagersResponse, error)

	// CreateManagerWithBodyWithResponse request with any body
	CreateManagerWithBodyWithResponse(ctx context.Context, domain string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateManagerResponse, error)

	CreateManagerWithResponse(ctx context.Context, domain string, body CreateManagerJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateManagerResponse, error)

	// DeleteManagerWithResponse request
	DeleteManagerWithResponse(ctx context.Context, domain string, email string, reqEditors ...RequestEditorFn) (*DeleteManagerResponse, error)

	// FindManagerWithResponse request
	FindManagerWithResponse(ctx context.Context, domain string, email string, reqEditors ...RequestEditorFn) (*FindManagerResponse, error)

	// ListUserDomainWithResponse request
	ListUserDomainWithResponse(ctx context.Context, domain string, reqEditors ...RequestEditorFn) (*ListUserDomainResponse, error)

	// ListRelaysWithResponse request
	ListRelaysWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListRelaysResponse, error)

	// CreateRelayWithBodyWithResponse request with any body
	CreateRelayWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRelayResponse, error)

	CreateRelayWithResponse(ctx context.Context, body CreateRelayJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRelayResponse, error)

	// DeleteRelayWithResponse request
	DeleteRelayWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*DeleteRelayResponse, error)

	// FindRelayWithResponse request
	FindRelayWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*FindRelayResponse, error)

	// UpdateRelayWithBodyWithResponse request with any body
	UpdateRelayWithBodyWithResponse(ctx context.Context, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRelayResponse, error)

	UpdateRelayWithResponse(ctx context.Context, name string, body UpdateRelayJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRelayResponse, error)

	// ListTokensWithResponse request
	ListTokensWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListTokensResponse, error)

	// CreateTokenWithBodyWithResponse request with any body
	CreateTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTokenResponse, error)

	CreateTokenWithResponse(ctx context.Context, body CreateTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTokenResponse, error)

	// DeleteTokenWithResponse request
	DeleteTokenWithResponse(ctx context.Context, tokenId string, reqEditors ...RequestEditorFn) (*DeleteTokenResponse, error)

	// FindTokenWithResponse request
	FindTokenWithResponse(ctx context.Context, tokenId string, reqEditors ...RequestEditorFn) (*FindTokenResponse, error)

	// UpdateTokenWithBodyWithResponse request with any body
	UpdateTokenWithBodyWithResponse(ctx context.Context, tokenId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateTokenResponse, error)

	UpdateTokenWithResponse(ctx context.Context, tokenId string, body UpdateTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateTokenResponse, error)

	// FindTokensOfUserWithResponse request
	FindTokensOfUserWithResponse(ctx context.Context, email string, reqEditors ...RequestEditorFn) (*FindTokensOfUserResponse, error)

	// CreateTokenWithBodyWithResponse request with any body
	CreateTokenWithBodyWithResponse(ctx context.Context, email string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTokenResponse, error)

	CreateTokenWithResponse(ctx context.Context, email string, body CreateTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTokenResponse, error)

	// ListUserWithResponse request
	ListUserWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListUserResponse, error)

	// CreateUserWithBodyWithResponse request with any body
	CreateUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateUserResponse, error)

	CreateUserWithResponse(ctx context.Context, body CreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateUserResponse, error)

	// DeleteUserWithResponse request
	DeleteUserWithResponse(ctx context.Context, email string, reqEditors ...RequestEditorFn) (*DeleteUserResponse, error)

	// FindUserWithResponse request
	FindUserWithResponse(ctx context.Context, email string, reqEditors ...RequestEditorFn) (*FindUserResponse, error)

	// UpdateUserWithBodyWithResponse request with any body
	UpdateUserWithBodyWithResponse(ctx context.Context, email string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateUserResponse, error)

	UpdateUserWithResponse(ctx context.Context, email string, body UpdateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUserResponse, error)
}

type ListAliasResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Alias
}

// Status returns HTTPResponse.Status
func (r ListAliasResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAliasResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAliasResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Response
	JSON400      *Response
	JSON404      *Response
	JSON409      *Response
}

// Status returns HTTPResponse.Status
func (r CreateAliasResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAliasResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindAliasFilterDomainResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Alias
	JSON400      *Response
	JSON404      *Response
}

// Status returns HTTPResponse.Status
func (r FindAliasFilterDomainResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindAliasFilterDomainResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAliasResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Response
	JSON400      *Response
	JSON404      *Response
}

// Status returns HTTPResponse.Status
func (r DeleteAliasResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAliasResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindAliasResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Alias
	JSON400      *Response
	JSON404      *Response
}

// Status returns HTTPResponse.Status
func (r FindAliasResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindAliasResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateAliasResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Response
	JSON400      *Response
	JSON404      *Response
}

// Status returns HTTPResponse.Status
func (r UpdateAliasResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateAliasResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAlternativeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]AlternativeDomain
}

// Status returns HTTPResponse.Status
func (r ListAlternativeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAlternativeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAlternativeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Response
	JSON400      *Response
	JSON404      *Response
	JSON409      *Response
}

// Status returns HTTPResponse.Status
func (r CreateAlternativeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAlternativeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAlternativeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Response
	JSON400      *Response
	JSON404      *Response
	JSON409      *Response
}

// Status returns HTTPResponse.Status
func (r DeleteAlternativeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAlternativeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindAlternativeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AlternativeDomain
	JSON400      *Response
	JSON404      *Response
}

// Status returns HTTPResponse.Status
func (r FindAlternativeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindAlternativeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListDomainResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]DomainGet
}

// Status returns HTTPResponse.Status
func (r ListDomainResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListDomainResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateDomainResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Response
	JSON400      *Response
	JSON409      *Response
}

// Status returns HTTPResponse.Status
func (r CreateDomainResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateDomainResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteDomainResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Response
	JSON400      *Response
	JSON404      *Response
}

// Status returns HTTPResponse.Status
func (r DeleteDomainResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteDomainResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindDomainResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DomainGet
	JSON400      *Response
	JSON404      *Response
}

// Status returns HTTPResponse.Status
func (r FindDomainResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindDomainResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateDomainResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Response
	JSON400      *Response
	JSON404      *Response
	JSON409      *Response
}

// Status returns HTTPResponse.Status
func (r UpdateDomainResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateDomainResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GenerateDkimResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Response
	JSON400      *Response
	JSON404      *Response
}

// Status returns HTTPResponse.Status
func (r GenerateDkimResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GenerateDkimResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListManagersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Manager
	JSON400      *Response
	JSON404      *Response
}

// Status returns HTTPResponse.Status
func (r ListManagersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListManagersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateManagerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Response
	JSON400      *Response
	JSON404      *Response
	JSON409      *Response
}

// Status returns HTTPResponse.Status
func (r CreateManagerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateManagerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteManagerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Response
	JSON400      *Response
	JSON404      *Response
}

// Status returns HTTPResponse.Status
func (r DeleteManagerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteManagerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindManagerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Response
	JSON400      *Response
	JSON404      *Response
}

// Status returns HTTPResponse.Status
func (r FindManagerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindManagerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListUserDomainResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UserGet
	JSON400      *Response
	JSON404      *Response
}

// Status returns HTTPResponse.Status
func (r ListUserDomainResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListUserDomainResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListRelaysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Relay
}

// Status returns HTTPResponse.Status
func (r ListRelaysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListRelaysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateRelayResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Response
	JSON400      *Response
	JSON409      *Response
}

// Status returns HTTPResponse.Status
func (r CreateRelayResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateRelayResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteRelayResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Response
	JSON400      *Response
	JSON404      *Response
}

// Status returns HTTPResponse.Status
func (r DeleteRelayResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteRelayResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindRelayResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Relay
	JSON400      *Response
	JSON404      *Response
}

// Status returns HTTPResponse.Status
func (r FindRelayResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindRelayResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateRelayResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Response
	JSON400      *Response
	JSON404      *Response
}

// Status returns HTTPResponse.Status
func (r UpdateRelayResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateRelayResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListTokensResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]TokenGetResponse
}

// Status returns HTTPResponse.Status
func (r ListTokensResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListTokensResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TokenPostResponse
	JSON400      *Response
	JSON404      *Response
}

// Status returns HTTPResponse.Status
func (r CreateTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Response
	JSON404      *Response
}

// Status returns HTTPResponse.Status
func (r DeleteTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TokenGetResponse
	JSON404      *Response
}

// Status returns HTTPResponse.Status
func (r FindTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Response
	JSON400      *Response
	JSON404      *Response
}

// Status returns HTTPResponse.Status
func (r UpdateTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindTokensOfUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TokenGetResponse
	JSON400      *Response
	JSON404      *Response
}

// Status returns HTTPResponse.Status
func (r FindTokensOfUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindTokensOfUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TokenPostResponse
	JSON400      *Response
	JSON404      *Response
}

// Status returns HTTPResponse.Status
func (r CreateTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]UserGet
}

// Status returns HTTPResponse.Status
func (r ListUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Response
	JSON400      *Response
	JSON409      *Response
}

// Status returns HTTPResponse.Status
func (r CreateUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Response
	JSON400      *Response
	JSON404      *Response
}

// Status returns HTTPResponse.Status
func (r DeleteUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FindUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UserGet
	JSON400      *Response
	JSON404      *Response
}

// Status returns HTTPResponse.Status
func (r FindUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FindUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Response
	JSON400      *Response
	JSON404      *Response
}

// Status returns HTTPResponse.Status
func (r UpdateUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// ListAliasWithResponse request returning *ListAliasResponse
func (c *ClientWithResponses) ListAliasWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListAliasResponse, error) {
	rsp, err := c.ListAlias(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAliasResponse(rsp)
}

// CreateAliasWithBodyWithResponse request with arbitrary body returning *CreateAliasResponse
func (c *ClientWithResponses) CreateAliasWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAliasResponse, error) {
	rsp, err := c.CreateAliasWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAliasResponse(rsp)
}

func (c *ClientWithResponses) CreateAliasWithResponse(ctx context.Context, body CreateAliasJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAliasResponse, error) {
	rsp, err := c.CreateAlias(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAliasResponse(rsp)
}

// FindAliasFilterDomainWithResponse request returning *FindAliasFilterDomainResponse
func (c *ClientWithResponses) FindAliasFilterDomainWithResponse(ctx context.Context, domain string, reqEditors ...RequestEditorFn) (*FindAliasFilterDomainResponse, error) {
	rsp, err := c.FindAliasFilterDomain(ctx, domain, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindAliasFilterDomainResponse(rsp)
}

// DeleteAliasWithResponse request returning *DeleteAliasResponse
func (c *ClientWithResponses) DeleteAliasWithResponse(ctx context.Context, alias string, reqEditors ...RequestEditorFn) (*DeleteAliasResponse, error) {
	rsp, err := c.DeleteAlias(ctx, alias, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAliasResponse(rsp)
}

// FindAliasWithResponse request returning *FindAliasResponse
func (c *ClientWithResponses) FindAliasWithResponse(ctx context.Context, alias string, reqEditors ...RequestEditorFn) (*FindAliasResponse, error) {
	rsp, err := c.FindAlias(ctx, alias, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindAliasResponse(rsp)
}

// UpdateAliasWithBodyWithResponse request with arbitrary body returning *UpdateAliasResponse
func (c *ClientWithResponses) UpdateAliasWithBodyWithResponse(ctx context.Context, alias string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAliasResponse, error) {
	rsp, err := c.UpdateAliasWithBody(ctx, alias, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAliasResponse(rsp)
}

func (c *ClientWithResponses) UpdateAliasWithResponse(ctx context.Context, alias string, body UpdateAliasJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAliasResponse, error) {
	rsp, err := c.UpdateAlias(ctx, alias, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAliasResponse(rsp)
}

// ListAlternativeWithResponse request returning *ListAlternativeResponse
func (c *ClientWithResponses) ListAlternativeWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListAlternativeResponse, error) {
	rsp, err := c.ListAlternative(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAlternativeResponse(rsp)
}

// CreateAlternativeWithBodyWithResponse request with arbitrary body returning *CreateAlternativeResponse
func (c *ClientWithResponses) CreateAlternativeWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAlternativeResponse, error) {
	rsp, err := c.CreateAlternativeWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAlternativeResponse(rsp)
}

func (c *ClientWithResponses) CreateAlternativeWithResponse(ctx context.Context, body CreateAlternativeJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAlternativeResponse, error) {
	rsp, err := c.CreateAlternative(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAlternativeResponse(rsp)
}

// DeleteAlternativeWithResponse request returning *DeleteAlternativeResponse
func (c *ClientWithResponses) DeleteAlternativeWithResponse(ctx context.Context, alt string, reqEditors ...RequestEditorFn) (*DeleteAlternativeResponse, error) {
	rsp, err := c.DeleteAlternative(ctx, alt, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAlternativeResponse(rsp)
}

// FindAlternativeWithResponse request returning *FindAlternativeResponse
func (c *ClientWithResponses) FindAlternativeWithResponse(ctx context.Context, alt string, reqEditors ...RequestEditorFn) (*FindAlternativeResponse, error) {
	rsp, err := c.FindAlternative(ctx, alt, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindAlternativeResponse(rsp)
}

// ListDomainWithResponse request returning *ListDomainResponse
func (c *ClientWithResponses) ListDomainWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListDomainResponse, error) {
	rsp, err := c.ListDomain(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListDomainResponse(rsp)
}

// CreateDomainWithBodyWithResponse request with arbitrary body returning *CreateDomainResponse
func (c *ClientWithResponses) CreateDomainWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDomainResponse, error) {
	rsp, err := c.CreateDomainWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDomainResponse(rsp)
}

func (c *ClientWithResponses) CreateDomainWithResponse(ctx context.Context, body CreateDomainJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDomainResponse, error) {
	rsp, err := c.CreateDomain(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDomainResponse(rsp)
}

// DeleteDomainWithResponse request returning *DeleteDomainResponse
func (c *ClientWithResponses) DeleteDomainWithResponse(ctx context.Context, domain string, reqEditors ...RequestEditorFn) (*DeleteDomainResponse, error) {
	rsp, err := c.DeleteDomain(ctx, domain, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteDomainResponse(rsp)
}

// FindDomainWithResponse request returning *FindDomainResponse
func (c *ClientWithResponses) FindDomainWithResponse(ctx context.Context, domain string, reqEditors ...RequestEditorFn) (*FindDomainResponse, error) {
	rsp, err := c.FindDomain(ctx, domain, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindDomainResponse(rsp)
}

// UpdateDomainWithBodyWithResponse request with arbitrary body returning *UpdateDomainResponse
func (c *ClientWithResponses) UpdateDomainWithBodyWithResponse(ctx context.Context, domain string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateDomainResponse, error) {
	rsp, err := c.UpdateDomainWithBody(ctx, domain, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateDomainResponse(rsp)
}

func (c *ClientWithResponses) UpdateDomainWithResponse(ctx context.Context, domain string, body UpdateDomainJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateDomainResponse, error) {
	rsp, err := c.UpdateDomain(ctx, domain, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateDomainResponse(rsp)
}

// GenerateDkimWithResponse request returning *GenerateDkimResponse
func (c *ClientWithResponses) GenerateDkimWithResponse(ctx context.Context, domain string, reqEditors ...RequestEditorFn) (*GenerateDkimResponse, error) {
	rsp, err := c.GenerateDkim(ctx, domain, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGenerateDkimResponse(rsp)
}

// ListManagersWithResponse request returning *ListManagersResponse
func (c *ClientWithResponses) ListManagersWithResponse(ctx context.Context, domain string, reqEditors ...RequestEditorFn) (*ListManagersResponse, error) {
	rsp, err := c.ListManagers(ctx, domain, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListManagersResponse(rsp)
}

// CreateManagerWithBodyWithResponse request with arbitrary body returning *CreateManagerResponse
func (c *ClientWithResponses) CreateManagerWithBodyWithResponse(ctx context.Context, domain string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateManagerResponse, error) {
	rsp, err := c.CreateManagerWithBody(ctx, domain, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateManagerResponse(rsp)
}

func (c *ClientWithResponses) CreateManagerWithResponse(ctx context.Context, domain string, body CreateManagerJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateManagerResponse, error) {
	rsp, err := c.CreateManager(ctx, domain, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateManagerResponse(rsp)
}

// DeleteManagerWithResponse request returning *DeleteManagerResponse
func (c *ClientWithResponses) DeleteManagerWithResponse(ctx context.Context, domain string, email string, reqEditors ...RequestEditorFn) (*DeleteManagerResponse, error) {
	rsp, err := c.DeleteManager(ctx, domain, email, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteManagerResponse(rsp)
}

// FindManagerWithResponse request returning *FindManagerResponse
func (c *ClientWithResponses) FindManagerWithResponse(ctx context.Context, domain string, email string, reqEditors ...RequestEditorFn) (*FindManagerResponse, error) {
	rsp, err := c.FindManager(ctx, domain, email, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindManagerResponse(rsp)
}

// ListUserDomainWithResponse request returning *ListUserDomainResponse
func (c *ClientWithResponses) ListUserDomainWithResponse(ctx context.Context, domain string, reqEditors ...RequestEditorFn) (*ListUserDomainResponse, error) {
	rsp, err := c.ListUserDomain(ctx, domain, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListUserDomainResponse(rsp)
}

// ListRelaysWithResponse request returning *ListRelaysResponse
func (c *ClientWithResponses) ListRelaysWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListRelaysResponse, error) {
	rsp, err := c.ListRelays(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListRelaysResponse(rsp)
}

// CreateRelayWithBodyWithResponse request with arbitrary body returning *CreateRelayResponse
func (c *ClientWithResponses) CreateRelayWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRelayResponse, error) {
	rsp, err := c.CreateRelayWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRelayResponse(rsp)
}

func (c *ClientWithResponses) CreateRelayWithResponse(ctx context.Context, body CreateRelayJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRelayResponse, error) {
	rsp, err := c.CreateRelay(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRelayResponse(rsp)
}

// DeleteRelayWithResponse request returning *DeleteRelayResponse
func (c *ClientWithResponses) DeleteRelayWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*DeleteRelayResponse, error) {
	rsp, err := c.DeleteRelay(ctx, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRelayResponse(rsp)
}

// FindRelayWithResponse request returning *FindRelayResponse
func (c *ClientWithResponses) FindRelayWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*FindRelayResponse, error) {
	rsp, err := c.FindRelay(ctx, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindRelayResponse(rsp)
}

// UpdateRelayWithBodyWithResponse request with arbitrary body returning *UpdateRelayResponse
func (c *ClientWithResponses) UpdateRelayWithBodyWithResponse(ctx context.Context, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRelayResponse, error) {
	rsp, err := c.UpdateRelayWithBody(ctx, name, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRelayResponse(rsp)
}

func (c *ClientWithResponses) UpdateRelayWithResponse(ctx context.Context, name string, body UpdateRelayJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRelayResponse, error) {
	rsp, err := c.UpdateRelay(ctx, name, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRelayResponse(rsp)
}

// ListTokensWithResponse request returning *ListTokensResponse
func (c *ClientWithResponses) ListTokensWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListTokensResponse, error) {
	rsp, err := c.ListTokens(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListTokensResponse(rsp)
}

// CreateTokenWithBodyWithResponse request with arbitrary body returning *CreateTokenResponse
func (c *ClientWithResponses) CreateTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTokenResponse, error) {
	rsp, err := c.CreateTokenWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTokenResponse(rsp)
}

func (c *ClientWithResponses) CreateTokenWithResponse(ctx context.Context, body CreateTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTokenResponse, error) {
	rsp, err := c.CreateToken(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTokenResponse(rsp)
}

// DeleteTokenWithResponse request returning *DeleteTokenResponse
func (c *ClientWithResponses) DeleteTokenWithResponse(ctx context.Context, tokenId string, reqEditors ...RequestEditorFn) (*DeleteTokenResponse, error) {
	rsp, err := c.DeleteToken(ctx, tokenId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTokenResponse(rsp)
}

// FindTokenWithResponse request returning *FindTokenResponse
func (c *ClientWithResponses) FindTokenWithResponse(ctx context.Context, tokenId string, reqEditors ...RequestEditorFn) (*FindTokenResponse, error) {
	rsp, err := c.FindToken(ctx, tokenId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindTokenResponse(rsp)
}

// UpdateTokenWithBodyWithResponse request with arbitrary body returning *UpdateTokenResponse
func (c *ClientWithResponses) UpdateTokenWithBodyWithResponse(ctx context.Context, tokenId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateTokenResponse, error) {
	rsp, err := c.UpdateTokenWithBody(ctx, tokenId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateTokenResponse(rsp)
}

func (c *ClientWithResponses) UpdateTokenWithResponse(ctx context.Context, tokenId string, body UpdateTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateTokenResponse, error) {
	rsp, err := c.UpdateToken(ctx, tokenId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateTokenResponse(rsp)
}

// FindTokensOfUserWithResponse request returning *FindTokensOfUserResponse
func (c *ClientWithResponses) FindTokensOfUserWithResponse(ctx context.Context, email string, reqEditors ...RequestEditorFn) (*FindTokensOfUserResponse, error) {
	rsp, err := c.FindTokensOfUser(ctx, email, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindTokensOfUserResponse(rsp)
}

// CreateTokenWithBodyWithResponse request with arbitrary body returning *CreateTokenResponse
func (c *ClientWithResponses) CreateTokenWithBodyWithResponse(ctx context.Context, email string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTokenResponse, error) {
	rsp, err := c.CreateTokenWithBody(ctx, email, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTokenResponse(rsp)
}

func (c *ClientWithResponses) CreateTokenWithResponse(ctx context.Context, email string, body CreateTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTokenResponse, error) {
	rsp, err := c.CreateToken(ctx, email, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTokenResponse(rsp)
}

// ListUserWithResponse request returning *ListUserResponse
func (c *ClientWithResponses) ListUserWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListUserResponse, error) {
	rsp, err := c.ListUser(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListUserResponse(rsp)
}

// CreateUserWithBodyWithResponse request with arbitrary body returning *CreateUserResponse
func (c *ClientWithResponses) CreateUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateUserResponse, error) {
	rsp, err := c.CreateUserWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUserResponse(rsp)
}

func (c *ClientWithResponses) CreateUserWithResponse(ctx context.Context, body CreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateUserResponse, error) {
	rsp, err := c.CreateUser(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUserResponse(rsp)
}

// DeleteUserWithResponse request returning *DeleteUserResponse
func (c *ClientWithResponses) DeleteUserWithResponse(ctx context.Context, email string, reqEditors ...RequestEditorFn) (*DeleteUserResponse, error) {
	rsp, err := c.DeleteUser(ctx, email, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteUserResponse(rsp)
}

// FindUserWithResponse request returning *FindUserResponse
func (c *ClientWithResponses) FindUserWithResponse(ctx context.Context, email string, reqEditors ...RequestEditorFn) (*FindUserResponse, error) {
	rsp, err := c.FindUser(ctx, email, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFindUserResponse(rsp)
}

// UpdateUserWithBodyWithResponse request with arbitrary body returning *UpdateUserResponse
func (c *ClientWithResponses) UpdateUserWithBodyWithResponse(ctx context.Context, email string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateUserResponse, error) {
	rsp, err := c.UpdateUserWithBody(ctx, email, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUserResponse(rsp)
}

func (c *ClientWithResponses) UpdateUserWithResponse(ctx context.Context, email string, body UpdateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUserResponse, error) {
	rsp, err := c.UpdateUser(ctx, email, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUserResponse(rsp)
}

// ParseListAliasResponse parses an HTTP response from a ListAliasWithResponse call
func ParseListAliasResponse(rsp *http.Response) (*ListAliasResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAliasResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Alias
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateAliasResponse parses an HTTP response from a CreateAliasWithResponse call
func ParseCreateAliasResponse(rsp *http.Response) (*CreateAliasResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAliasResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseFindAliasFilterDomainResponse parses an HTTP response from a FindAliasFilterDomainWithResponse call
func ParseFindAliasFilterDomainResponse(rsp *http.Response) (*FindAliasFilterDomainResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindAliasFilterDomainResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Alias
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseDeleteAliasResponse parses an HTTP response from a DeleteAliasWithResponse call
func ParseDeleteAliasResponse(rsp *http.Response) (*DeleteAliasResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAliasResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseFindAliasResponse parses an HTTP response from a FindAliasWithResponse call
func ParseFindAliasResponse(rsp *http.Response) (*FindAliasResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindAliasResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Alias
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateAliasResponse parses an HTTP response from a UpdateAliasWithResponse call
func ParseUpdateAliasResponse(rsp *http.Response) (*UpdateAliasResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateAliasResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseListAlternativeResponse parses an HTTP response from a ListAlternativeWithResponse call
func ParseListAlternativeResponse(rsp *http.Response) (*ListAlternativeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAlternativeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []AlternativeDomain
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateAlternativeResponse parses an HTTP response from a CreateAlternativeWithResponse call
func ParseCreateAlternativeResponse(rsp *http.Response) (*CreateAlternativeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAlternativeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseDeleteAlternativeResponse parses an HTTP response from a DeleteAlternativeWithResponse call
func ParseDeleteAlternativeResponse(rsp *http.Response) (*DeleteAlternativeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAlternativeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseFindAlternativeResponse parses an HTTP response from a FindAlternativeWithResponse call
func ParseFindAlternativeResponse(rsp *http.Response) (*FindAlternativeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindAlternativeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AlternativeDomain
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseListDomainResponse parses an HTTP response from a ListDomainWithResponse call
func ParseListDomainResponse(rsp *http.Response) (*ListDomainResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListDomainResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []DomainGet
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateDomainResponse parses an HTTP response from a CreateDomainWithResponse call
func ParseCreateDomainResponse(rsp *http.Response) (*CreateDomainResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateDomainResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseDeleteDomainResponse parses an HTTP response from a DeleteDomainWithResponse call
func ParseDeleteDomainResponse(rsp *http.Response) (*DeleteDomainResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteDomainResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseFindDomainResponse parses an HTTP response from a FindDomainWithResponse call
func ParseFindDomainResponse(rsp *http.Response) (*FindDomainResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindDomainResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DomainGet
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateDomainResponse parses an HTTP response from a UpdateDomainWithResponse call
func ParseUpdateDomainResponse(rsp *http.Response) (*UpdateDomainResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateDomainResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseGenerateDkimResponse parses an HTTP response from a GenerateDkimWithResponse call
func ParseGenerateDkimResponse(rsp *http.Response) (*GenerateDkimResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GenerateDkimResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseListManagersResponse parses an HTTP response from a ListManagersWithResponse call
func ParseListManagersResponse(rsp *http.Response) (*ListManagersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListManagersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Manager
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseCreateManagerResponse parses an HTTP response from a CreateManagerWithResponse call
func ParseCreateManagerResponse(rsp *http.Response) (*CreateManagerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateManagerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseDeleteManagerResponse parses an HTTP response from a DeleteManagerWithResponse call
func ParseDeleteManagerResponse(rsp *http.Response) (*DeleteManagerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteManagerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseFindManagerResponse parses an HTTP response from a FindManagerWithResponse call
func ParseFindManagerResponse(rsp *http.Response) (*FindManagerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindManagerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseListUserDomainResponse parses an HTTP response from a ListUserDomainWithResponse call
func ParseListUserDomainResponse(rsp *http.Response) (*ListUserDomainResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListUserDomainResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserGet
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseListRelaysResponse parses an HTTP response from a ListRelaysWithResponse call
func ParseListRelaysResponse(rsp *http.Response) (*ListRelaysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListRelaysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Relay
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateRelayResponse parses an HTTP response from a CreateRelayWithResponse call
func ParseCreateRelayResponse(rsp *http.Response) (*CreateRelayResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateRelayResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseDeleteRelayResponse parses an HTTP response from a DeleteRelayWithResponse call
func ParseDeleteRelayResponse(rsp *http.Response) (*DeleteRelayResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteRelayResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseFindRelayResponse parses an HTTP response from a FindRelayWithResponse call
func ParseFindRelayResponse(rsp *http.Response) (*FindRelayResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindRelayResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Relay
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateRelayResponse parses an HTTP response from a UpdateRelayWithResponse call
func ParseUpdateRelayResponse(rsp *http.Response) (*UpdateRelayResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateRelayResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseListTokensResponse parses an HTTP response from a ListTokensWithResponse call
func ParseListTokensResponse(rsp *http.Response) (*ListTokensResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListTokensResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []TokenGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateTokenResponse parses an HTTP response from a CreateTokenWithResponse call
func ParseCreateTokenResponse(rsp *http.Response) (*CreateTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TokenPostResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseDeleteTokenResponse parses an HTTP response from a DeleteTokenWithResponse call
func ParseDeleteTokenResponse(rsp *http.Response) (*DeleteTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseFindTokenResponse parses an HTTP response from a FindTokenWithResponse call
func ParseFindTokenResponse(rsp *http.Response) (*FindTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TokenGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateTokenResponse parses an HTTP response from a UpdateTokenWithResponse call
func ParseUpdateTokenResponse(rsp *http.Response) (*UpdateTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseFindTokensOfUserResponse parses an HTTP response from a FindTokensOfUserWithResponse call
func ParseFindTokensOfUserResponse(rsp *http.Response) (*FindTokensOfUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindTokensOfUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TokenGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseCreateTokenResponse parses an HTTP response from a CreateTokenWithResponse call
func ParseCreateTokenResponse(rsp *http.Response) (*CreateTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TokenPostResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseListUserResponse parses an HTTP response from a ListUserWithResponse call
func ParseListUserResponse(rsp *http.Response) (*ListUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []UserGet
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateUserResponse parses an HTTP response from a CreateUserWithResponse call
func ParseCreateUserResponse(rsp *http.Response) (*CreateUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseDeleteUserResponse parses an HTTP response from a DeleteUserWithResponse call
func ParseDeleteUserResponse(rsp *http.Response) (*DeleteUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseFindUserResponse parses an HTTP response from a FindUserWithResponse call
func ParseFindUserResponse(rsp *http.Response) (*FindUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FindUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserGet
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateUserResponse parses an HTTP response from a UpdateUserWithResponse call
func ParseUpdateUserResponse(rsp *http.Response) (*UpdateUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}
